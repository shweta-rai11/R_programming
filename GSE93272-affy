library(affy)
library(GEOquery)
library(ggplot2)
library(reshape2)
library(arrayQualityMetrics)
library(MatrixGenerics)


setwd("~/Desktop/geo/GSE93272_RAW-new/GSE93272_RAW/unzip")
#setwd(<raw files>) # change to the directory containing .CEL files

# Download raw CEL files
getGEOSuppFiles("GSE93272")
# Untar and unzip CEL files from the command line

# Figure out which samples belong 2 which platform
gse <- getGEO("GSE93272")
pData(gse[[1]])$supplementary_file
write.csv(pData(gse[[1]]), file = "sample_info.csv")

# Add Trait and Disease_state variables
pData(gse[[1]])$Trait <- pData(gse[[1]])$`characteristics_ch1.1`
pData(gse[[1]])$Disease_state <- pData(gse[[1]])$`characteristics_ch1.6`

setwd("raw_files/")
AffyBatch <- ReadAffy()

# Run background correction, normalization and summarization
Affy_norm <- expresso(AffyBatch, bgcorrect.method="rma",
                      normalize.method="quantiles", pmcorrect.method="pmonly",
                      summary.method="medianpolish")
pData(Affy_norm) <- pData(gse[[1]])
# Save normalized ExpressionSet object 
save(Affy_norm, file="GSE93272_affy_norm.RData")

#############################################

write.csv(exprs(Affy_norm), file="GSE93272_affy_normexpressions.csv")

# Get sample data
write.csv(pData(Affy_norm), file="GSE93272_affy_norm_phenodata.csv")
###############################

# Load the dataset
load("~/Desktop/geo/GSE93272_RAW-new/GSE93272_RAW/unzip/GSE93272_affy_norm.RData")
show(Affy_norm)

# Select clinico-pathological variables from sample metadata
sample_data <- pData(Affy_norm)
sample_data <- data.frame(Trait = sample_data$characteristics_ch1.1,
                          Gender = sample_data$characteristics_ch1.6)
unique(sample_data$Trait)

# Modify variable definitions
sample_data$Trait[sample_data$Trait == "disease state: healthy control"] <- "control"
sample_data$Trait[sample_data$Trait == "disease state: RA"] <- "RA"


sample_data$Gender <- gsub("gender: " , "", sample_data$Gender)

################

# Add modified variables to pheno data object
pData(Affy_norm)$Trait <- sample_data$Trait
pData(Affy_norm)$Gender <- sample_data$Gender
#pData(eset)$cell_type <- sample_data$cell_type
#pData(eset)$Age <- sample_data$Age
#pData(eset)$Age_group <- sample_data$age_group
head(pData(Affy_norm))
# Convert age to categorical variable
#age_group <- cut(sample_data$Age, breaks = c(15, 45, 82), right = TRUE)
#sample_data$age_group <- age_group

# Extract the expression data
edata <- exprs(Affy_norm)

# Check the dimensions of the data
cat("Dimensions of edata:", dim(edata), "\n")

# Ensure there are enough rows for normalization
if (nrow(edata) < 2) {
  stop("The data matrix has too few rows for reliable normalization.")
}

# Normalize the data
edata <- normalizeVSN(edata)

# Select top 500 genes with highest Mean Absolute Deviations (MAD)
mads <- rowMads(edata)
names(mads) <- rownames(edata)
mads_sorted <- sort(mads, decreasing = TRUE)
top500_genes <- names(mads_sorted)[1:500]

# Extract the matrix with top 500 most variable values
top500 <- edata[top500_genes, ]

# Check for NA, Inf, -Inf values and handle them
if(any(is.na(top500))) {
  top500[is.na(top500)] <- 0
}
if(any(is.infinite(top500))) {
  top500[is.infinite(top500)] <- 0
}

# Ensure correct row names for annotation
rownames(sample_data) <- colnames(top500)

# Print min and max values to verify they are finite
min_val <- min(top500, na.rm = TRUE)
max_val <- max(top500, na.rm = TRUE)
cat("Min:", min_val, "Max:", max_val, "\n")

# Cluster genes and samples, plot heatmap
pdf("heatmap_without_correction.pdf", width = 7, height = 8)
pheatmap(top500, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100),
         scale = "row", 
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "ward.D2",
         annotation_col = sample_data[,-3], 
         show_rownames = FALSE)
dev.off()

# -------------------------- PCA ---------------------------------------- #
# Plot PCA without batch correction
p <- pca(edata, metadata = sample_data[,-3], removeVar = 0.9)

# Create biplot and draw stat ellipses at 95% CI around groups
biplot(p,
       colby = 'Trait', colkey = c('Control' = 'forestgreen', 'RA' = 'purple'),
       # ellipse config
       ellipse = TRUE,
       ellipseType = 't',
       ellipseLevel = 0.95,
       ellipseFill = TRUE,
       ellipseAlpha = 1/4,
       ellipseLineSize = 1.0,
       xlim = c(-125,125), ylim = c(-50, 80),
       hline = 0, vline = c(-25, 0, 25),
       legendPosition = 'top', legendLabSize = 16, legendIconSize = 8.0)
ggsave("PCA_biplot_without_correct.pdf", device = "pdf", units = "in", 
       width = 6, height = 6)

# Create pairs plot
pairsplot(p,
          components = getComponents(p, c(1:6)),
          triangle = TRUE, trianglelabSize = 12,
          hline = 0, vline = 0,
          pointSize = 0.4,
          gridlines.major = FALSE, gridlines.minor = FALSE,
          colby = 'Trait',
          title = 'Pairs plot', plotaxes = FALSE,
          margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
ggsave("pairs_plot_without_correct.pdf", device = "pdf", units = "in", 
       width = 6, height = 6)

# Plot loadings, fancy
plotloadings(p,
             rangeRetain = 0.01,
             labSize = 4.0,
             title = 'Loadings plot',
             subtitle = 'PC1, PC2, PC3, PC4, PC5',
             caption = 'Top 1% variables',
             shape = 24,
             col = c('limegreen', 'black', 'red3'),
             drawConnectors = TRUE)
ggsave("loadings_plot_without_correct.pdf", device = "pdf", units = "in", 
       width = 6, height = 7)
# Convert categorical variables to numeric factors
sample_data$Trait <- as.numeric(as.factor(sample_data$Trait))
sample_data$Gender <- as.numeric(as.factor(sample_data$Gender))

# Recreate the PCA object to include the updated metadata
p <- pca(edata, metadata = sample_data[,-3], removeVar = 0.9)

# Create eigencorrelation plot with numeric metadata
pdf("eigencor_plot_without_correct.pdf", width = 7, height = 7) 
eigencorplot(p,
             metavars = c('Trait','Gender'))
dev.off()


# Identify optimal number of PCs
horn <- parallelPCA(exprs(Affy_norm)) # Horn's method
horn$n # 7

elbow <- findElbowPoint(p$variance)
elbow # 6

# Create screeplot
screeplot(p, components = getComponents(p, 1:10),
          vline = c(horn$n, elbow)) + 
  geom_label(aes(x = horn$n + 1, y = 50,
                 label = 'Horn\'s', vjust = -1, size = 8)) +
  geom_label(aes(x = elbow + 1, y = 50,
                 label = 'Elbow method', vjust = -1, size = 8))
ggsave("screeplot_without_correct.pdf", device = "pdf", units = "in", 
       width = 7, height = 7)

# -------------------- Detect DEGs without correction ----------------------- #
# Create expression set object with VSN normalized data

# Normalize the expression data
expr_vsn <- normalizeVSN(exprs(Affy_norm))

# Extract sample names from each component
sampleNames_assayData <- colnames(expr_vsn)
sampleNames_phenoData <- sampleNames(phenoData(Affy_norm))
sampleNames_protocolData <- sampleNames(protocolData(Affy_norm))

# Print sample names to diagnose the issue
cat("Sample names in assayData:", sampleNames_assayData, "\n")
cat("Sample names in phenoData:", sampleNames_phenoData, "\n")
cat("Sample names in protocolData:", sampleNames_protocolData, "\n")

# Assuming the correct sample names are those in expr_vsn, set them in phenoData and protocolData
sampleNames(phenoData(Affy_norm)) <- sampleNames_assayData
sampleNames(protocolData(Affy_norm)) <- sampleNames_assayData

# Verify the changes
sampleNames_phenoData <- sampleNames(phenoData(Affy_norm))
sampleNames_protocolData <- sampleNames(protocolData(Affy_norm))

cat("Updated sample names in phenoData:", sampleNames_phenoData, "\n")
cat("Updated sample names in protocolData:", sampleNames_protocolData, "\n")

# Create the ExpressionSet object again
eset_vsn <- ExpressionSet(assayData = expr_vsn, 
                          phenoData = phenoData(Affy_norm), 
                          featureData = featureData(Affy_norm),
                          protocolData = protocolData(Affy_norm))

# Verify the ExpressionSet object
print(eset_vsn)

# Proceed with the analysis
pheno <- pData(eset_vsn)

# Create model matrix with adjustment variables
design <- model.matrix(~ Gender + Trait, data = pheno)

head(design)
# Ensure the fit object is properly created and contains the necessary components
str(fit)

# Check the names of the coefficients in the fit object to ensure "TraitRA" is correct
colnames(fit$coefficients)

# Ensure fit$genes exists and contains valid data
if (!is.null(fit$genes) && nrow(fit$genes) > 0) {
  # Set the number parameter correctly
  number_of_genes <- nrow(fit$genes)
} else {
  # If fit$genes is NULL or empty, use a default value
  number_of_genes <- Inf
}

# Print the number of genes to verify
cat("Number of genes: ", number_of_genes, "\n")

# Proceed with topTable function using the correct number of genes
res <- topTable(fit, coef = "TraitRA", number = number_of_genes, adjust.method = "BH")

# Check the top results
head(res)


# Fit the model
fit <- lmFit(eset_vsn, design)
fit <- eBayes(fit)
# Proceed with topTable function using the correct number of genes
res <- topTable(fit, coef = "TraitRA", number = number_of_genes, adjust.method = "BH")

head(res)
write.csv(res, file = "RA_vs_Controls_without_correct.csv")

# How many genes are significant (adj.p.value < 0.05 and absolute 
# fold change > 1.5)
sum(res$adj.P.Val < 0.05) # 2720 probes
# Save the results for significant probes
write.csv(res[res$adj.P.Val < 0.05,], 
          file = "RA_vs_Controls_sig_only_without_correct.csv")
###############################

# Print the number of significant probes selected
cat("Number of significant probes selected:", length(sig_probes), "\n")

# Print the dimensions of the scaled expression data
cat("Dimensions of the scaled expression data (rows x columns):", n_rows, "x", n_cols, "\n")

# Print a summary of the scaled expression data
cat("Summary of the scaled expression data:\n")
print(summary(scaled_sig_exp))

# Stop execution if the data is insufficient for clustering
if (n_rows < 2 || n_cols < 2) {
  stop("Insufficient data for clustering. Check the dimensions of the scaled expression data.")
}

# Generate the heatmap
pdf("heatmap_significant_without_correct.pdf", width = 7, height = 6)
pheatmap(scaled_sig_exp, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "ward.D2",
         annotation_col = annot, 
         show_rownames = FALSE)
dev.off()


#######################

# Create MA plot showing the relationship between average expression
# and log fold change
res <- res[with(res, order(logFC)),]
res$threshold <- as.factor(res$adj.P.Val < 0.05)
ggplot(data=res, aes(x=log2(AveExpr), y=logFC, colour=threshold)) + 
  geom_point(alpha=0.4, size=1.8) + 
  geom_hline(aes(yintercept = 0), colour = "blue", size = 1.2) +
  ylim(c(min(res$logFC), max(res$logFC))) + 
  xlab("Mean expression") + 
  ylab("Log2 Fold Change") + 
  theme(axis.title.x = element_text(face = "bold", size = 15),
        axis.text.x = element_text(face = "bold", size = 12)) +
  theme(axis.title.y = element_text(face = "bold", size = 15),
        axis.text.y = element_text(face = "bold", size = 12)) +
  scale_colour_discrete(name = "p.adjusted < 0.05") +
  theme(legend.title = element_text(face = "bold", size = 15)) +
  theme(legend.text = element_text(size = 14))
ggsave("MAplot_without_correct.pdf", device = "pdf", width = 7, height = 5)

# Create volcano plot
res <- res[with(res, order(logFC)),]
res$threshold <- as.factor(res$adj.P.Val < 0.05)
ggplot(data=res, aes(x=logFC, y=-log10(adj.P.Val), colour=threshold)) + 
  geom_point(alpha=0.4, size=1.75) + xlim(c(min(res$logFC), 
                                            c(max(res$logFC)))) +
  ylim(c(min(-log10(res$adj.P.Val)), max(-log10(res$adj.P.Val)))) + 
  xlab("log2 fold change") + 
  ylab("-log10 adjusted p-value") +
  theme(axis.text=element_text(size=12, face="bold")) +
  theme(axis.title=element_text(size=14)) +
  theme(legend.title=element_text(size=14)) +
  theme(legend.text=element_text(size=12))
ggsave("volcano_plot_without_correct.pdf", device = "pdf", 
       width = 5, height = 7)
