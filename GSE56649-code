library(affy)
library(GEOquery)
library(ggplot2)
library(reshape2)
library(arrayQualityMetrics)
library(MatrixGenerics)

# Identify biomarkers to predict response to therapy 
# in polyarticular juvenile idiopathic arthritis (JIA) 
# using gene expression microarrays.
# 42 samples from 13 controls, 14 active patients, 9 patients in clinical 
# remission with medication (CRM), and 6 patients in clinical 
# remission without medication (CR). All patients had polyarticular JIA.


setwd("~/Desktop/geo/bisi/GSE55457_RAW (1)/unzip")
#setwd(<raw files>) # change to the directory containing .CEL files

# Download raw CEL files
getGEOSuppFiles("GSE56649")
# Untar and unzip CEL files from the command line

# Figure out which samples belong 2 which platform
gse <- getGEO("GSE56649")
pData(gse[[1]])$supplementary_file
write.csv(pData(gse[[1]]), file = "sample_info.csv")

# Add Trait and Disease_state variables
pData(gse[[1]])$Disease_state <- pData(gse[[1]])$`characteristics_ch1`
#pData(gse[[1]])$Disease_state <- pData(gse[[1]])$`symptom:ch1`

#setwd("raw_files/")
AffyBatch <- ReadAffy()

# Run background correction, normalization and summarization
Affy_norm <- expresso(AffyBatch, bgcorrect.method="rma",
                      normalize.method="quantiles", pmcorrect.method="pmonly",
                      summary.method="medianpolish")
pData(Affy_norm) <- pData(gse[[1]])
# Save normalized ExpressionSet object 
save(Affy_norm, file="GSE56649_affy_norm1.RData")

# Examine array qualities
# Create violin plot after normalization
# Get expression matrix
expr <- exprs(Affy_norm)
head(expr)
# Melt the expression matrix
expr_melt <- melt(as.data.frame(expr))
names(expr_melt) <- c("sample", "intensity")
head(expr_melt)

# The samples were background corrected but not normalized
ggplot(expr_melt, aes(x=sample, y = log2(intensity))) +
  geom_violin() + 
  geom_boxplot(width = 0.1) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggsave("GSE56649_intensities_violin_normalized.pdf", device = "pdf", units = "in", 
       width = 8, height = 5)

# Run array quality control analysis using arrayQualityMetrics
arrayQualityMetrics(Affy_norm,
                    outdir = "GSE15645_arrayQualityReport",
                    force = T,
                    do.logtransform = T,
                    intgroup = c("Disease_state"),
                    spatial = TRUE,
                    reporttitle = paste("arrayQualityMetrics report for", 
                                        deparse(substitute(expressionset)))
)


##############################
library(ggplot2)
library(pheatmap)
library(reshape2)
library(arrayQualityMetrics)
library(Biobase)
library(limma)
library(MatrixGenerics)
library(RColorBrewer)
library(vsn)



# Load GSE15573 data set using GEOquery, here I loaded saved 
# data object from my system
load("~/Desktop/geo/bisi/GSE55457_RAW (1)/unzip/GSE56649.RData")

#load("GSE56649_affy_norm1.RData")
show(eset)



# --------------------------------------------------------------------# 
# Examine metadata
head(pData(eset))

# Select clinico-pathological variables from sample metadata
sample_data <- pData(eset)
sample_data <- data.frame(Disease_state = sample_data$characteristics_ch1)
head(sample_data)
tail(sample_data)

# Modify the variable definitions to make them more palatable
sample_data$Disease_state[sample_data$Disease_state == "disease state: rheumatoid arthritis"] <- "RA"
sample_data$Disease_state[sample_data$Disease_state == "disease state: healthy control"] <- "Control"
#sample_data$Gender <- gsub("gender: " , "", sample_data$Gender)
#sample_data$Age <- gsub("age: " , "", sample_data$Age)
#class(sample_data$Age) # age is still a character, we need to turn it into numbers
#sample_data$Age <- as.numeric(sample_data$Age)
#class(sample_data$Age)

# Crosstabulate sample data
table(sample_data$Disease_state)
# Female Male
# Control     10    5
# RA          14    4
# The samples appear balanced relative to Gender, but the majority of samples
# are female

# Convert age to categorical variable
#sort(sample_data$Age)
# 45 - 80 years age range, so big difference in patient ranges
# We can separate the patients into middle-aged and old categories
'''age_group<-cut(sample_data$Age, 
               breaks=c(44, 58, 81), right = T)'''
#age_group
#sample_data$age_group <- age_group
#table(sample_data$Trait, sample_data$age_group)
# (45,58] (58,81]
# Control      10       4
# RA           8      10
# Note that there are only 4 patients in old age control category

# -------------------------------------------------------------------------- #
# Explore array intensity distribution
# Get expression matrix
expr <- exprs(eset)
head(expr)
# Melt the expression matrix
expr_melt <- melt(as.data.frame(expr))
names(expr_melt) <- c("sample", "intensity")
head(expr_melt)

p <- ggplot(expr_melt, aes(x=sample, y = log2(intensity))) +
  geom_violin() + 
  geom_boxplot(width = 0.1) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
p
ggsave("intensities_violin.pdf", device = "pdf", units = "in", 
       width = 8, height = 5)  

# Run array quality control analysis using arrayQualityMetrics
arrayQualityMetrics(eset,
                    outdir = "GSE15573_arrayQualityReport",
                    force = T,
                    do.logtransform = T,
                    intgroup = c("characteristics_ch1"),
                    spatial = TRUE,
                    reporttitle = paste("arrayQualityMetrics report for", 
                                        deparse(substitute(expressionset)))
)
#this is for QC

# -------------------------------------------------------------------------- #
# Load required library (if not already loaded)
library(stats)

# Cluster the samples
# Transform gene expression values using Variance Stabilizing Transformation
expr <- exprs(eset)
meanSdPlot(expr)
expr <- normalizeVSN(expr)
head(expr)
meanSdPlot(expr)

# Select top 500 genes with highest Mean Absolute Deviations (MAD)
mads_sorted <- sort(rowMads(expr), decreasing = T)
mads_sorted <- mads_sorted[1:500]
head(mads_sorted)
mads_sorted

# Extract the matrix with top 500 most variable values
top500 <- expr[which(rownames(expr) %in% names(mads_sorted)),]

# Create column annotation for heatmap
head(sample_data)
rownames(sample_data) <- colnames(expr)

#if you wish you can seperate codes for better understanding.
#################
library(limma)
library(pheatmap)
library(ggplot2)
library(RColorBrewer)
# This script is designed to detect differentially 
# expressed genes with limma assuming that the data
# is already normalized

#setwd("~/Desktop/geo/bisi/GSE55457_RAW (1)/unzip/GSE56649.RData")

# Load GSE15573 data set using GEOquery, here I loaded saved 
# data object from my system
load("GSE56649.RData")
show(eset) # The data was normalized using quantile normalization in BeadStudio

# lmFit() function from limma requires log transformed data
# Here we will apply variance stabilizing normalization to make array
# intensities log transfomed and normally distributed. We need to 
# re-create expressionSet object with transformed data
exp_vsn <- normalizeVSN(exprs(eset))
meanSdPlot(exp_vsn)
eset <- ExpressionSet(assayData = exp_vsn, phenoData = phenoData(eset), 
                      featureData = featureData(eset))


# --------------------------------------------------------------------# 
# Examine metadata
head(pData(eset))
sample_data <- pData(eset)

sample_data <- data.frame(Disease_state = sample_data$characteristics_ch1)
head(sample_data)
tail(sample_data)

# Modify the variable definitions to make them more palatable
sample_data$Disease_state[sample_data$Disease_state == "disease state: rheumatoid arthritis"] <- "RA"
sample_data$Disease_state[sample_data$Disease_state == "disease state: healthy control"] <- "Control"

# We can separate the patients into middle-aged and old categories
'''age_group<-cut(sample_data$Age, 
               breaks=c(44, 58, 81), right = T)'''
#age_group
#sample_data$age_group <- age_group

# Add modified variables to pData object
pData(eset)$Disease_state <- sample_data$Disease_state
#pData(eset)$Gender <- sample_data$Gender
#pData(eset)$Age <- sample_data$Age
#pData(eset)$Age_group <- sample_data$age_group
head(pData(eset))

# Create model matrix to compare RA samples to controls, 
# while accounting for biological factors of no interest, i.e.
# age and gender
# The variables need to be converted to factors
pData(eset)$Disease_state <- factor(pData(eset)$Disease_state, levels = c("Control", "RA"))
# Note, that we set Control as a reference level
pData(eset)$Disease_state

# Convert other variables to factors
#pData(eset)$Gender <- factor(pData(eset)$Gender)
#pData(eset)$Gender
#pData(eset)$Age_group <- factor(pData(eset)$Age_group)
#pData(eset)$Age_group

# Create design matrix
Disease_state <- pData(eset)$Disease_state
#Gender <- pData(eset)$Gender
#Age_group <- pData(eset)$Age_group
design <- model.matrix(~Disease_state)
head(design)

# Fit the model
fit <- lmFit(eset, design)
fit <- eBayes(fit)
res <- topTable(fit, coef = "Disease_stateRA", number = dim(fit$genes)[1], 
                adjust.method = "BH") 
head(res)
write.csv(res, file = "RA_vs_Controls.csv")

# How many genes are significant (adj.p.value < 0.05 and absolute 
# fold change > 1.5)
sum(res$adj.P.Val < 0.05) # 406 probes
# Save the results for significant probes
write.csv(res[res$adj.P.Val < 0.05,], 
          file = "RA_vs_Controls_sig_only.csv")


# Plot a heatmap of differentially expressed probes
sig_probes <- res[which(res$adj.P.Val < 0.05),]$ID
expr <- exprs(eset)
sig_exp <- expr[rownames(expr) %in% sig_probes,]

annot <- data.frame(Disease_state = pData(eset)$Disease_state)
rownames(annot) <- rownames(pData(eset))
head(annot)

# Clustering and heatmap for significant probes (adj. p-values < 0.05)
pdf("heatmap_significant.pdf", width = 7, height = 6)
pheatmap(sig_exp, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name =
                                                   "RdYlBu")))(100),
         scale="row", 
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "ward.D2",
         annotation_col = annot, 
         show_rownames = F)
dev.off()

# Create MA plot showing the relationship between average expression
# and log fold change
res <- res[with(res, order(logFC)),]
res$threshold <- as.factor(res$adj.P.Val < 0.05)
ggplot(data=res, aes(x=log2(AveExpr), y=logFC, colour=threshold)) + 
  geom_point(alpha=0.4, size=1.8) + 
  geom_hline(aes(yintercept = 0), colour = "blue", size = 1.2) +
  ylim(c(min(res$logFC), max(res$logFC))) + 
  xlab("Mean expression") + 
  ylab("Log2 Fold Change") + 
  theme(axis.title.x = element_text(face = "bold", size = 15),
        axis.text.x = element_text(face = "bold", size = 12)) +
  theme(axis.title.y = element_text(face = "bold", size = 15),
        axis.text.y = element_text(face = "bold", size = 12)) +
  scale_colour_discrete(name = "p.adjusted < 0.05") +
  theme(legend.title = element_text(face = "bold", size = 15)) +
  theme(legend.text = element_text(size = 14))
ggsave("MAplot.pdf", device = "pdf", width = 7, height = 5)

# Create volcano plot
res <- res[with(res, order(logFC)),]
#res$threshold <- as.factor(abs(res$logFC) > 0.59 & res$adj.P.Val < 0.05)
res$threshold <- as.factor(res$adj.P.Val < 0.05)
ggplot(data=res, aes(x=logFC, y=-log10(adj.P.Val), colour=threshold)) + 
  geom_point(alpha=0.4, size=1.75) + xlim(c(min(res$logFC), 
                                            c(max(res$logFC)))) +
  ylim(c(min(-log10(res$adj.P.Val)), max(-log10(res$adj.P.Val)))) + 
  xlab("log2 fold change") + 
  ylab("-log10 adjusted p-value") +
  theme(axis.text=element_text(size=12, face="bold")) +
  theme(axis.title=element_text(size=14)) +
  theme(legend.title=element_text(size=14)) +
  theme(legend.text=element_text(size=12))
ggsave("volcano_plot.pdf", device = "pdf", width = 5, height = 7) 
